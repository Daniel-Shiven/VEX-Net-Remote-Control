#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Motor,  port1,           motorRIGHT,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port5,           motorARM,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           motorCLAW,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motorLEFT,     tmotorVex393_HBridge, openLoop)
//*!!Code  generated by 'Dan Niel S, Jead I. Nhite For Ran L and Looka M' configuration wizards               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Btn 6U is for BadAutoDrive																																	*|
|*    2)  Btn 5U is for GyroControl                          *|
|*    3)  Tilting the controller LEFT gives a NEGATIVE reading on X.                                  *|
|*    4)  Holding the controller RIGHT gives a POSITIVE reading on X.                                 *|
|*                                                                                                    *|
\*----------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------*/
void joystickControl()													//Joystick Control
{

	motor[motorLEFT] = vexRT[Ch3];
	motor[motorRIGHT] = vexRT[Ch2];
}

//---------------------------------------------------------------------------------------------//

void armControl()															//Claw ARM Control
{
	if(vexRT[Btn8U] == 1)
	{
		motor[port5] = -40;
	}
	else if(vexRT[Btn8D] == 1)
	{
		motor[port5] = 40;
	}
	else
	{
		motor[port5] = 0;
	}
}

//---------------------------------------------------------------------------------------------//

void clawControl()														//Claw Control
{
	if(vexRT[Btn8L] == 1)
	{
		motor[port6] = -30;
	}
	else if(vexRT[Btn8R] == 1)
	{
		motor[port6] = 30;
	}
	else
	{
		motor[port6] = 0;
	}
}
//---------------------------------------------------------------------------------------------//

int nicePilot(int nice)														//Set Nice
{
	if(vexRT[Btn6U] == 1)
	{
		if(nice==1)
		{
			nice = 0;
		} else if(nice==0)
		{
			nice = 1;
		}
	}

	return nice;
}

//---------------------------------------------------------------------------------------------//

void autoDrive()														//AutoDrive
{
	if(SensorValue(sonarSensor) > 25 || SensorValue(sonarSensor) < 0)
	{
		motor[motorRIGHT] = motor[motorLEFT] = 60;
	}

	if(SensorValue(sonarSensor) < 25)
	{
		motor[motorRIGHT] = 60;
		motor[motorLEFT] = -60;
		wait1Msec(988);
	}
}

//---------------------------------------------------------------------------------------------//

int gyroPilot(int gyro)														//Set Gyro
{
	if(vexRT[Btn5U] == 1)
	{
		if(gyro==1)
		{
			gyro = 0;
		} else if(gyro==0)
		{
			gyro = 1;
		}
	}

	return gyro;
}

//---------------------------------------------------------------------------------------------//

void gyroControl() {
	int accel_x   = 0;      // Will hold the controller-accelerometer X reading.
	int accel_y   = 0;      // Will hold the controller-accelerometer Y reading.

	int prev_x    = 0;      // Will hold the previous accelerometer X reading (for comparison).
	int prev_y    = 0;      // Will hold the previous accelerometer Y reading (for comparison).

	int threshold = 10;     /* Used to cancel 'noise' of low values as well as */
	/* ignore spikes in accelerometer sensor readings. */

		prev_x = accel_x;           // update previous x reading to 'accel_x'
		prev_y = accel_y;           // update previous y reading to 'accel_y'
		accel_x = vexRT[AccelX];    // update 'accel_x' to new current reading
		accel_y = vexRT[AccelY];    // update 'accel_y' to new current reading

		// is abs(current - prev) < threshold?
		if( (abs(accel_x - prev_x) < threshold) || (abs(accel_y - prev_y) > threshold) )
		{
			// YES.
			// Are either of them over the 'noise' threshold?
			if( (abs(accel_x) > threshold) || (abs(accel_y) > threshold) )
			{
				// YES.
				if(accel_y > 0) // going backwards?
				{
					motor[motorLEFT]  = ((-1 * accel_y) - accel_x)*2;
					motor[motorRIGHT] = ((-1 * accel_y) + accel_x)*2;
				}
				else  // going forward, or point turn:
				{
					motor[motorLEFT]  = ((-1 * accel_y) + accel_x)*2;
					motor[motorRIGHT] = ((-1 * accel_y) - accel_x)*2;
				}
			}
			// NO - give no power to motors, joystick is in center position (or near enough to it)
			else
			{
				motor[motorLEFT]  = 0;
				motor[motorRIGHT] = 0;
			}
			// NO - make no changes.
	}
}
	//---------------------------------------------------------------------------------------------//

task main()
	{
		int nice = 0;
		int gyro = 0;

		while(69==69)
		{

			nice = nicePilot(nice);
			gyro = gyroPilot(gyro);
			if(nice==1)
			{
				armControl();
				clawControl();
				autoDrive();
			}
			else if(gyro==1)
			{
				gyroControl();
				armControl();
				clawControl();
			}
			else
			{
				joystickControl();
				armControl();
				clawControl();
			}
		}
}
